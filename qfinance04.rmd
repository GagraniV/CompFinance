---
title: "Finacial risk volatility modeling (ARCH, GARCH, & EGRCH) with R"
author: "Vijaya Gagrani"
date: "May 2015"
output:
  slidy_presentation: default
  ioslides_presentation:
  keep_md: yes
  transition: faster
  widescreen: yes
  beamer_presentation: default
---
   
```{r Set_ChunkOptions, echo=FALSE}
#Select Chunk and package options @ http://yihui.name/knitr/options
knitr::opts_chunk$set(comment = NA, echo= FALSE, message = FALSE, fig.align='center', warning = FALSE,cache=FALSE)
```
## Background and Objective

Finacial risk univariate volatility models included in this analyis are ARCH, GARCH, and EGRCH. These models are based on a least squares models assumptions that the expected value of all squared error terms or variance is same at any given point (homoskendasticity). The opposite concept is heterskendasticity, where variance of the error term is not constant for all points, and thats what the center of the Autoregressive Conditional Heteroskedasticity models (ARCH).

Volatility is important in assessing financial risk, portfolio selection, and derivative pricing. However, in financial time series, volatility occurs in clusters like periods of high volatility follows with high volatility and vice versa.  In addtion, for financial time series more recent events would be more relevant then the distant past events.  ARCH models utilize the heteroskedasticity in time series data to measure volatility (standard deviation). THE ARCH models are applied to forecast mean and variance of return based on the past information. In addtion, these models allow to use the best weights in forecasting variance instead of using equal weights for all past events.

An ARCH model is simila to the AR (1) model on squared residuals. In an ARCH (1) model, next period’s variance only depends on last period’s squared residual. The ARCH model is extended as a Generalized ARCH or GARCH model by making it conditional to both squared residuals and squared observations in past. The typical GARCH model is described as GARCH(1,1) model. The first subscript in GARCH reefers to autoregressive lags or ARCH and second subscript refers to the moving average lags, respectively. These models are basically setup for one period forecast, however a long-horizon forecasting can be constructed. The ARCH/GARCH approaches are widely used in situations where volatility of return is a central issue.  
http://www.cmat.edu.uy/~mordecki/hk/engle.pdf
http://faculty.washington.edu/ezivot/econ589/econ589univariateGarch.r
http://www.r-bloggers.com/a-practical-introduction-to-garch-modeling/
https://onlinecourses.science.psu.edu/stat510/node/61

Financial institutions measure the risk using a Value-at-Risk (VaR), usually calculated at the 99% confidence level. Generally, for a stock prices the low volatility periods follows by the periods of high volatility and vice versa (cluster volatility). This phenomenon is visually detectable in simple line plots. In addtion, we can test it applying the two commonly used tests(The Ljung-Box test for autocorrelation in squared returns and the Lagrange Multiplier (LM test)). In rugarch library there are diffrent functions for model specification, parameter estimation, backtesting, and forecasting. 

```{r}
Box.test(coredata(intc^2), type = "Ljung-Box", lag = 12)
#Reject the null hypothesis of no autocorrelations in the squared returns at the 1% significance level
#LM test
install.packages("FinTS")
library("FinTS")
ArchTest(coredata(intc))

library("rugarch")
#specify the model
intc_garch11_spec <- ugarchspec(variance.model = list(+   garchOrder = c(1, 1)),+  mean.model = list(armaOrder = c(0, 0)))
#model estimation
intc_garch11_fit <- ugarchfit(spec = intc_garch11_spec,+  data = intc)
#backtesting: to check the model perfromance 
intc_garch11_roll <- ugarchroll(intc_garch11_spec, intc,+   n.start = 120, refit.every = 1, refit.window = "moving",+   solver = "hybrid", calculate.VaR = TRUE, VaR.alpha = 0.01,+   keep.coef = TRUE)
#examining backtest report
report(intc_garch11_roll, type = "VaR", VaR.alpha = 0.01,+   conf.level = 0.99)
#Kupiec's unconditional coverage compares the number of expected versus actual exceedances given the tail probability of VaR, while the Christoffersen test is a joint test of the unconditional coverage and the independence of the exceedances. In our case, despite the actual five exceedances versus an expectation of three, we can't reject the null hypothesis that the exceedances are correct and independent.
intc_VaR <- zoo(intc_garch11_roll@forecast$VaR[, 1])
index(intc_VaR) <- as.yearmon(rownames(intc_garch11_roll@forecast$VaR))
intc_actual <- zoo(intc_garch11_roll@forecast$VaR[, 2])
index(intc_actual) <- as.yearmon(rownames(intc_garch11_roll@forecast$VaR))
plot(intc_actual, type = "b", main = "99% 1 Month VaR Backtesting",+   xlab = "Date", ylab = "Return/VaR in percent")
lines(intc_VaR, col = "red")
legend("topright", inset=.05, c("Intel return","VaR"), col = c("black","red"), lty = c(1,1))
#forecasting
intc_garch11_fcst <- ugarchforecast(intc_garch11_fit, n.ahead = 12)

```
